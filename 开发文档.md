# 《圈圈物语》开发文档

## 1. 创意来源

本游戏根植于“休闲模拟经营”游戏类型，致力于打造一款风格治愈、节奏轻松的像素风田园生活模拟游戏。游戏以《星露谷物语》及《牧场物语》系列为灵感源泉，继承其经典的玩法框架与设计精髓，旨在为玩家构建一个充满生机与温情的数字田园避风港。

游戏的核心设计借鉴了经市场验证的成熟框架——**“耕种-收获-售卖-升级-扩大生产”** 这一完美的正反馈循环。该循环构成了游戏体验的基石，致力于为玩家提供持续且满足的成就感。

## 2. 需求分析

| 需求类别      | 具体功能                               | 用例描述                                                     |
| :------------ | :------------------------------------- | :----------------------------------------------------------- |
| **角色控制**  | 人物移动、碰撞检测                     | 玩家可以自由控制角色往四方移动；当遇到建筑物时，角色应无法穿透障碍，以避免穿模。 |
| **地图系统**  | 地图文件的导入与渲染、经传送点切换地图 | 系统需要将tmx地图文件正确导入进游戏中并渲染到游戏界面上；玩家可以通过传送点在不同的地图之间切换。 |
| **农业系统**  | 农作物的种植、生长和收割               | 玩家可以与田地交互将对应的种子种下；植物应随着时间的流逝进入不同的生长阶段；玩家可以将成熟的作物收割放入库存中。 |
| **畜牧系统**  | 鸡的养殖、产物收集                     | 玩家可以在鸡圈中养殖鸡；鸡应产出鸡蛋供玩家收集。             |
| **经济系统**  | 物品库存、向NPC售卖作物                | 玩家应可以清晰查看库存中收集的物品数量；玩家可以向NPC售卖库存中的农产物来换取金币。 |
| **工具系统**  | 道具栏、工具切换、使用工具效果         | 玩家可以通过按键切换不同的工具使用以达到不同的目的（种植/收割）。 |
| **NPC与社交** | NPC实体、对话系统                      | 玩家可以通过互动与NPC角色进行对话。                          |
| **时间系统**  | 时间系统、昼夜滤镜                     | 玩家可以看到明确的游戏内时间；随着时段变化，游戏界面应呈现不同的效果。 |
| **进度系统**  | 农场升级                               | 玩家可以花费金币解锁农场的更多区域。                         |
| **数据管理**  | 游戏存档与读档                         | 玩家可以正常的存入或读取游戏数据。                           |
| **视听体验**  | 背景音乐、音效控制器                   | 游戏应为游戏场景、事件添加独特的BGM和音效。                  |

## 3. 技术选型

### 3.1 开发环境

本游戏在 **Windows 11** 操作系统下进行开发，采用 **Visual Studio Code** 作为开发工具。VSCode 作为轻量级的代码编辑器，有着UI简洁、启动速度快、内存占用低、内置Git功能等优点。

![image-20250912000619049](C:\Users\suin\AppData\Roaming\Typora\typora-user-images\image-20250912000619049.png)

### 3.2 JAVA

本项目采用 **纯Java SE** 技术栈进行开发，不依赖任何第三方游戏引擎或框架。此选择旨在深度掌控游戏底层逻辑，从零构建一套完整的游戏架构。与使用现成的引擎不同，纯Java实现意味着开发者对游戏循环、渲染管线、内存管理等功能的实现能有深入的理解。项目的技术实现大量依赖于Java标准库中的`java.awt`和`javax.swing`等组件，这些核心图形与UI库为游戏提供了强大的底层支持。

### 3.3 Git

本项目通过 **Git** 和 **Github Desktop** 工具的协助对源代码和开发资产进行高效的版本管理。在开发过程中，通过定期执行**commit操作**，详细记录了每个开发阶段的代码变更，这些包含明确提交信息的commit构成了项目的完整发展日志，为代码审查和问题追溯提供了清晰的历史依据。

<img src="C:\Users\suin\AppData\Roaming\Typora\typora-user-images\image-20250911235751999.png" alt="image-20250911235751999" style="zoom:67%;" />

### 3.4 TMX

本项目采用 **TMX（Tiled Map XML）格式** 作为核心的地图数据存储方案，并通过**Tiled Map Editor**这款专业的2D地图编辑器进行所有游戏地图的创作与编辑。TMX格式的选择是基于其开源、灵活且被广泛支持的行业标准地位，它完美地实现了地图内容设计与程序逻辑的分离，极大地提升了开发效率和协作便利性。

在技术实现层面，项目开发了专用的**TMX文件解析器**，用于读取和解释由Tiled编辑器生成的XML格式地图数据。解析器能够高效地处理多个图层（Tile Layer），将瓦片集（Tileset）中的图像资源正确地渲染到游戏画面中，构建出丰富的游戏世界。更重要的是，它充分利用了TMX格式中的**对象层（Object Layer）**，该层用于定义游戏中的逻辑实体。地图中的碰撞箱、NPC生成点、传送门区域等关键信息，都作为自定义属性存储在对象层中。这种设计使得策划和美术人员可以在不修改代码的情况下，直接通过Tiled编辑器调整游戏世界的布局和逻辑元素，实现了真正的数据驱动开发。

通过将TMX解析器与游戏引擎紧密集成，我们成功地将视觉表现与游戏逻辑解耦。所有地图相关的数据，包括瓦片渲染顺序、图层层级关系以及逻辑对象的属性，都能从TMX文件中动态加载。这种架构不仅简化了地图的迭代和调试过程，也为未来扩展新的地图类型和交互元素提供了极大的灵活性，奠定了游戏世界可扩展性的坚实基础。

![image-20250912000226032](C:\Users\suin\AppData\Roaming\Typora\typora-user-images\image-20250912000226032.png)

### 3.5 多媒体素材

本游戏的多媒体素材主要来源于 **[itch.io](https://itch.io/)** 平台，该平台是独立游戏开发者社区重要的资源分享与交流中心，提供了大量高质量且版权清晰的游戏素材。通过在此平台上精心挑选了风格统一的像素美术素材和音乐资源，确保所有视听元素在艺术风格上保持统一，不仅保证了项目的艺术品质，也显著降低了开发成本。

![image-20250912000454497](C:\Users\suin\AppData\Roaming\Typora\typora-user-images\image-20250912000454497.png)

## 4. 设计与实现

### 4.1  操控人物的站立与行走

本游戏采用**状态驱动**的动画系统来控制主角Farmer的站立与行走行为。通过精确的状态管理和帧动画控制，实现了流畅的四方向移动体验。

角色行为通过双状态变量进行管理：

- `currentStatus`: 记录当前显示状态
- `nextStatus`: 存储下一帧待切换状态

状态命名遵循`行为--方向`的规范格式（如：`move--up`、`stand--right`）。

**移动控制逻辑**

```java
public void move(int direction) {
    this.dir = direction;
    switch (direction) {
        case 0 -> { // 上
            xSpeed = 0;
            ySpeed = -MOVE_SPEED;
            nextStatus = "move--up";
        }
        // 其他方向处理...
    }
}

public void run() {
	while (true) {
		if (xspreed != 0) {
			if (mapViewer.checkWarp(getX() + xspreed, getY())) {
				continue; // 遇到传送点，跳过本次移动
			}
            if (mapViewer.checkCollision(getX() + xspreed, getY())) { // 碰撞检测
                setX(getX() + xspreed);
            }
        }
        
        if (yspreed != 0) {
			// y轴逻辑处理
		}

		// 改变pc图像
		switch (newStatus) {
			case "move--up" -> {
				BufferedImage[] anim = StaticValue.walk_U;
				updateframe(anim);
				setShow(anim[currentFrame]);
			}
			// 其他方向处理...
		}
	}
}
```

通过 `currentFrame` 计数器实现行走动画序列的循环播放，进入新状态时自动重置帧计数器，确保动画播放的完整性。

```java
private void updateAnimation(BufferedImage[] anim) {
    if (nextStatus.equals(currentStatus)) {
        currentFrame = (currentFrame + 1) % anim.length;
    } else {
        currentFrame = 0; // 状态切换时重置动画
        currentStatus = nextStatus;
    }
    setShow(anim[currentFrame]);
}
```

<img src="C:\Users\suin\Desktop\OOFarm\src\assets\characters\walk_r.png" alt="walk_r" style="zoom:150%;" />

### 4.2  音乐音效控制器 SoundManager 

本游戏采用**双通道音频管理系统**，通过 `SoundManager` 类统一管理背景音乐(BGM)和音效(SFX)的播放。每次播放音效时将创建一个新的Clip实例，以支持音效的重叠播放，并在音效播放结束后自动释放资源。

```java
AudioInputStream sfxStream = AudioSystem.getAudioInputStream(sfxUrl);  
Clip sfxClip = AudioSystem.getClip();
sfxClip.open(sfxStream);
sfxClip.start();
// 监听播放结束自动释放资源
sfxClip.addLineListener(event -> {
	if (event.getType() == LineEvent.Type.STOP) {
		sfxClip.close();
	}
});
```

采用了独立的音频通道确保BGM和SFX互不干扰，避免音效播放中断背景音乐。

```java
public static void playBGM() {
    if (bgmClip != null && bgmClip.isRunning()) {
        return; // 防止重复播放
    }
    
	URL bgmUrl = SoundManager.class.getClassLoader().getResource("assets/audio/bgm.wav");
	AudioInputStream bgmStream = AudioSystem.getAudioInputStream(bgmUrl);
	bgmClip = AudioSystem.getClip();
	bgmClip.open(bgmStream);
	bgmClip.loop(Clip.LOOP_CONTINUOUSLY); // 循环播放
	bgmClip.start();
}
```

### 4.3  读取tmx地图文件

本游戏采用基于 **Tiled地图编辑器** 的数据驱动地图系统，通过 `MapLoader` 类实现 TMX 格式地图的解析、渲染和管理。该系统支持分层式地图数据管理、碰撞检测、传送点、NPC放置和农田管理等复杂功能，为游戏世界构建提供完整解决方案。

```java
private void loadMap(String tmxFilePath) {
    URL url = getClass().getClassLoader().getResource("assets/map/" + tmxFilePath);
    if (url != null) {
        InputStream inputStream = url.openStream();
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        DocumentBuilder builder = factory.newDocumentBuilder();
        Document document = builder.parse(inputStream);
        document.getDocumentElement().normalize();

        // 解析地图基本属性
        Element mapElement = (Element) document.getElementsByTagName("map").item(0);
        mapWidth = Integer.parseInt(mapElement.getAttribute("width"));
        mapHeight = Integer.parseInt(mapElement.getAttribute("height"));

        // 解析地图属性（传送点、农田标识等）
        parseMapProperties(mapElement);
        
        // 解析图层数据（碰撞箱）
        parseLayers(document);
        
        // 解析对象层（NPC、农田等）
        parseObjectLayers(document);
    }
}
```

**地图属性解析**

在tmx文件的地图属性中，存有当前地图的所有传送点信息。这种设计模式可以在不修改代码的情况，轻易创建或修改传送点。

```java
private void parseMapProperties(Element mapElement) {
    NodeList propertiesList = mapElement.getElementsByTagName("properties");
    if (propertiesList.getLength() > 0) {
        Element propertiesElement = (Element) propertiesList.item(0);
        NodeList propertyList = propertiesElement.getElementsByTagName("property");
        
        for (int i = 0; i < propertyList.getLength(); i++) {
            Element propertyElement = (Element) propertyList.item(i);
            String name = propertyElement.getAttribute("name");
            String value = propertyElement.getAttribute("value");

            if ("Warp".equals(name)) {
                // 创建传送点
            }
        }
    }
}
```

<img src="C:\Users\suin\AppData\Roaming\Typora\typora-user-images\image-20250912002251147.png" alt="image-20250912002251147" style="zoom:67%;" />

**对象层实体解析**

在 Layer 层中存在农田和npc对象，通过解析器可以将它们的坐标区域计算出来并保存在对应的哈希表中，以供其他功能的逻辑实现使用。

```java
private void parseObjectLayers(Document document) {
    NodeList objectGroupList = document.getElementsByTagName("objectgroup");
    for (int i = 0; i < objectGroupList.getLength(); i++) {
        Element objectGroupElement = (Element) objectGroupList.item(i);
        NodeList objectList = objectGroupElement.getElementsByTagName("object");
        
        for (int j = 0; j < objectList.getLength(); j++) {
            Element objectElement = (Element) objectList.item(j);
            String name = objectElement.getAttribute("name");
            float x = Float.parseFloat(objectElement.getAttribute("x"));
            float y = Float.parseFloat(objectElement.getAttribute("y"));

            if ("TileData".equals(name)) {
                parseTileDataProperties(objectElement, x, y);
            }
        }
    }
}

private void parseTileDataProperties(Element objectElement, float x, float y) {
    NodeList propertiesList = objectElement.getElementsByTagName("properties");
    if (propertiesList.getLength() > 0) {
        Element propertiesElement = (Element) propertiesList.item(0);
        NodeList propertyList = propertiesElement.getElementsByTagName("property");
        
        int tileX = (int) (x / getTileWidth());
        int tileY = (int) (y / getTileWidth());
        int index = tileY * getMapWidth() + tileX;

        for (int k = 0; k < propertyList.getLength(); k++) {
            Element propertyElement = (Element) propertyList.item(k);
            String propName = propertyElement.getAttribute("name");
            String propValue = propertyElement.getAttribute("value");

            if ("canPlanted".equals(propName) && "True".equals(propValue)) {
                // 创建农田区块
            } else if ("NPC".equals(propName)) {
                // 创建NPC实例
            }
        }
    }
}
```

### 4.4  碰撞检测 

**碰撞箱**

系统通过解析器读取 TMX 文件中的图层信息。在解析过程中，当检测到名为"Buildings"的图层时，系统会将该图层的数据单独保存到 collisionData 中，作为碰撞检测专用数据。算法首先根据图块尺寸和缩放比例计算出行列坐标，随后通过行列坐标计算出一维索引值，用于在碰撞数据数组中快速查找对应的图块信息。当对应位置的图块ID为-1（empty）时表示为可通行区域，其他值则代表该区域存在障碍物。

```java
private void loadMap(String tmxFilePath) {
    NodeList layerList = document.getElementsByTagName("layer");
    for (int i = 0; i < layerList.getLength(); i++) {
        Element layerElement = (Element) layerList.item(i);
        NodeList dataList = layerElement.getElementsByTagName("data");
        if (dataList.getLength() > 0) {
            Element dataElement = (Element) dataList.item(0);
            String[] tileData = dataElement.getTextContent().trim().split(",");
            ArrayList<Integer> layer = new ArrayList<>();
            for (String tile : tileData) {
                layer.add(Integer.parseInt(tile.trim()) - 1); // TMX ID从1开始，减1方便处理
            }
            String layerName = layerElement.getAttribute("name");
            if ("Buildings".equals(layerName)) {
                collisionData = layer; // 只跟Buildings产生碰撞
            }

            layersData.add(layer); // 添加图层数据到 layersData 列表
        }
    }
}
    
public boolean checkCollision(int x, int y) {
	int tileX = (x - nowMap.getTileWidth()) / (nowMap.getTileWidth() * nowMap.getScaleFactor()) + 1;
	int tileY = (y - nowMap.getTileHeight()) / (nowMap.getTileWidth() * nowMap.getScaleFactor()) + 2;
	int index = tileY * nowMap.getMapWidth() + tileX;

	// 如果保存的value不是-1(empty), 则代表该位置有碰撞
	return nowMap.getCollisionData().get(index) == -1;
}
```

### 4.5  传送点的实现

传送点系统是游戏地图交互的重要组成部分，实现了不同地图场景之间的切换功能。系统首先通过解析器读取地图的属性列表，当检测到名为"Warp"的属性时，系统识别该属性包含传送点配置信息，并开始解析其值内容。每个传送点由5个参数组成：目标地图名称 `loc`、源坐标X `fromX`、源坐标Y `fromY`、目标坐标X `x`和目标坐标Y `y`。

<img src="C:\Users\suin\AppData\Roaming\Typora\typora-user-images\image-20250912003107014.png" alt="image-20250912003107014" style="zoom:67%;" />

系统通过源坐标计算出一维索引值 fromIndex，该索引作为键值存储在 warpsData 哈希表中，对应的Warp对象包含完整的传送信息。Warp类封装了传送所需的全部信息，包括目标地图、源位置索引和目标坐标。这种设计使得在游戏运行时能够快速检测玩家位置是否与任何传送点匹配，一旦检测到匹配即触发地图切换操作，并将玩家放置到指定的目标位置。

```java
Element propertyElement = (Element) propertyList.item(i);
String name = propertyElement.getAttribute("name");
String value = propertyElement.getAttribute("value");

// 读取传送点信息
if ("Warp".equals(name)) {
    String[] warpParts = value.split(" ");
    if (warpParts.length % 5 == 0) {
        for (int j = 0; j < warpParts.length; j += 5) {
            String loc = warpParts[i]; // 传送去的地图名字
            int fromX = Integer.parseInt(warpParts[j + 1]); // 传送点的X坐标
            int fromY = Integer.parseInt(warpParts[j + 2]); // 传送点的Y坐标
            int x = Integer.parseInt(warpParts[j + 3]); // 目标地图的X坐标
            int y = Integer.parseInt(warpParts[j + 4]); // 目标地图的Y坐标

            int fromIndex = fromY * getMapWidth() + fromX;
            Warp warpInfo = new Warp(loc, fromIndex, x, y);
            warpsData.put(fromIndex, warpInfo);
        }
    }
}
```

### 4.6  npc角色创建及与npc对话 

Character角色基类为游戏中的所有角色实体提供了统一的基础框架，定义了角色对象的共同属性和行为规范。该类封装了位置坐标、图像显示和事件交互等核心功能。

```java
public class Character {
    private int x;
    private int y;    // 坐标

    private BufferedImage show;

    private final ArrayList<String> eventsList = new ArrayList<>(); // 已触发的事件列表

    public Character(int x, int y) {
        setPosition(x, y);
    }

    public void addEvents(String eventID) {
        eventsList.add(eventID);
    }

    public boolean checkEvents(String eventID) { // 检测是否未经历某个事件
        return !eventsList.contains(eventID);
    }

    public void interact() { //进行交互
        System.out.println("[Interact] " + getClass().getSimpleName());
    }
}
```

对话系统是游戏角色交互的核心组件，负责管理和呈现游戏中所有的对话内容。对话气泡系统采用单例模式设计，确保全局只有一个对话实例存在。通过静态变量 `isTalking` 控制对话框的开启与关闭。

系统通过三个方法实现对话流程控制：

- `startTalking()`: 开启对话状态，激活对话框显示
- `stopTalking()`: 结束对话状态，隐藏对话框
- `isTalking()`: 检测当前对话状态，用于游戏逻辑判断

系统采用JSON文件存储对话内容，通过键值对方式组织：

```java
private static String loadMessageFromJSON(String FileName, String key) {
    InputStream inputStream = DialogBubble.class.getClassLoader().getResourceAsStream("assets/dialogue/" + FileName + ".json");

    StringBuilder message = new StringBuilder();
    BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream, StandardCharsets.UTF_8))) {
	String line;
	while ((line = reader.readLine()) != null) {
		message.append(line);
	}
    return parseJSON(message.toString(), key);
}
```

![image-20250911211037577](C:\Users\suin\AppData\Roaming\Typora\typora-user-images\image-20250911211037577.png)

通过**正则表达式**匹配高效提取特定对话内容：

```java
private static String parseJSON(String json, String key) {
    String regex = "\"" + key + "\"\\s*:\\s*\"([^\"]+)\"";
    Pattern pattern = Pattern.compile(regex);
    Matcher matcher = pattern.matcher(json);
    if (matcher.find()) {
        return matcher.group(1); // 返回匹配的对话内容
    }
    return "没有找到该对话";
}
```

系统通过重写 `interact()` 方法与NPC进行对话。当玩家与NPC对话时，`checkEvents()`用于检测是否第一次触发该对话，如果是则触发，并使用`addEvents()`标记该对话事件已发生，确保该剧情事件只会触发一次。

```java
if (checkEvents("hello")) {
    DialogBubble.talk(getClass().getSimpleName(), "hello");
    addEvents("hello");
}
```

![image-20250912003916652](C:\Users\suin\AppData\Roaming\Typora\typora-user-images\image-20250912003916652.png)

### 4.7  交易系统

农产品售卖机制是游戏经济体系的核心组成部分，通过重写 `interact()` 方法实现了玩家与NPC之间的交易功能。

如果玩家拥有可售卖的农产品，系统启动售卖流程：通过 `getItemCounts()` 方法检测物品栏中农产品的数量，当存在可售卖物品时，触发售卖对话并调用 `sellItem()` 方法执行售卖操作。

```java
if (InventoryBar.getInstance().getItemCounts() != 0) {
    DialogBubble.talk(getClass().getSimpleName(), "sell");
    InventoryBar.getInstance().sellItem();
}
```

```java
public void sellItem() {
    for (int i = 1; i < itemCounts.size(); i++) {
        if (itemCounts.get(i) != 0) {
            int currentMoney = itemCounts.get(0);
            // 计算售卖收入：物品数量 × 单价(10金币)
            int saleRevenue = itemCounts.get(i) * 10;
            itemCounts.set(0, currentMoney + saleRevenue);
            itemCounts.set(i, 0);
            repaint();
        }
    }
}
```

![image-20250912004400983](C:\Users\suin\AppData\Roaming\Typora\typora-user-images\image-20250912004400983.png)

### 4.8  角色道具栏

工具栏系统是游戏用户界面的重要组成部分，为玩家提供了工具选择的功能。该系统采用单例模式设计，实现了工具的可视化展示、选择状态管理和用户交互反馈。

**工具类型支持**：

- 索引0：镰刀（收割工具）
- 索引1：土豆种子（种植工具）
- 索引2：番茄种子（种植工具）

![image-20250912004439978](C:\Users\suin\AppData\Roaming\Typora\typora-user-images\image-20250912004439978.png)

通过`selectedToolIndex`来管理当前选择的工具状态，以触发不同的交互效果。

```java
if (selectedToolIndex == 0) {
    // 工具1（镰刀）：收获或销毁植物
    farmManager.handleHarvest(tileX, tileY);
} else {
    // 工具2和3（种子）：播种操作
    if (farmManager.canPlant(tileX, tileY)) {
        farmManager.plantSeed(selectedToolIndex + 1, tileX, tileY);
    }
}
```

### 4.9  农作物生长系统

农作物生长系统是游戏农业经营的核心模块，负责管理作物的种植、生长、成熟和收获全过程，实现了完整的农作物生命周期管理。

**核心属性定义**

- type：作物类型（2:土豆, 3:番茄, 1:可种植空地）
- growthStage：生长阶段（0-5共6个阶段）
- lastUpdateTime：上次更新时间戳
- growthTime：完整生长所需时间（秒）

本系统采用**状态驱动**的设计理念，将作物生命周期划分为种植、生长、成熟和收获四个明确阶段。

<img src="C:\Users\suin\Desktop\OOFarm\src\assets\map\plant.png" alt="plant" style="zoom:200%;" />

系统实时检测作物的生长时间，达到阶段时间后推进作物的生长阶段，生长完成后停止更新，避免不必要的计算。

```java
public void update() {
    if (growthStage < 5) {  // 未成熟
        long currentTime = System.currentTimeMillis();
        if (currentTime - lastUpdateTime >= growthTime * 1000) {
            growthStage++;
            lastUpdateTime = currentTime;
        }
    }
}
```

收获功能采用多条件判定机制，确保收获操作的合理性和有效性。系统首先检测目标位置是否为可种植区域，排除空操作情况。随后检查作物类型，避免对空地进行误收获操作。最后验证作物的成熟状态，只有完全成熟的作物才能被收获。根据作物类型向玩家物品栏添加对应的农产品，实现资源的有效转移。

```java
public void handleHarvest(int tileX, int tileY) {
    MapLoader nowMap = mapsData.nowMap;
    int index = tileY * nowMap.getMapWidth() + tileX;
    Plant plant = plants.get(index);

    if (plant == null) { // 非种植区域
        System.out.println("该区域不可种植！");
        return;
    }

    if (plant.getType() == 1) {	// 检查是否为空地
        System.out.println("这是块空地，什么都没有！");
        return;
    }

    if (!plant.isFullyGrown()) {
        System.out.println("该区域上的作物还不到收割的时候！");
        return;
    }
    
	SoundManager.playSFX("harvest.wav");	// 播放收获音效
	// 根据植物类型增加对应的计数
	InventoryBar.getInstance().addItem(plant.getType());
    System.out.println("收获【" + plant.getType() + "】！");
	// 收获后将地块恢复为可种植状态（type=1）
	plants.put(index, new Plant(1, plant.getX(), plant.getY()));
}
```

![image-20250912010501370](C:\Users\suin\AppData\Roaming\Typora\typora-user-images\image-20250912010501370.png)

### 4.10  鸡养殖系统 

鸡行为管理系统是游戏畜牧养殖的核心组件，通过状态机驱动和随机行为算法，模拟了鸡的自主移动和产蛋等行为。

鸡通过概率驱动的方式实现自主移动，模拟自然觅食行为，同时根据移动方向自动调整朝向，确保视觉一致性。鸡行走动画采用帧循环机制，实现流畅的行走效果。

```java
public void update() {
    long currentTime = System.currentTimeMillis();
    if (currentTime - lastUpdateTime > 500) { // 每500ms更新一次动画帧
        frameIndex = (frameIndex + 1) % 4;
        lastUpdateTime = currentTime;

        // 随机改变方向
        if (random.nextInt(100) < 20) {
            facingLeft = !facingLeft;
        }

        // 随机移动
        if (random.nextInt(100) < 80) {
            int dx = facingLeft ? -1 : 1;
            x += dx;
        }
        
        // 随机上下移动
        if (random.nextInt(100) < 30) {
            int dy = random.nextBoolean() ? -1 : 1;
            y += dy;
        }
    }
}
```

产蛋行为与游戏时间系统紧密关联，产蛋时间间隔设置为30分钟，实现规律性的产出：

```java
if (timeSystem.getMinute() % 30 == 0 && timeSystem.getSecond() == 0) {
    eggs.add(new Point(x, y));  // 每隔30分钟在鸡当前位置产蛋
}
```

鸡蛋收集逻辑实现：

```java
public void pickEgg(Chicken chicken, int tileX, int tileY) {
    Point targetPoint = new Point(tileX, tileY);
    ArrayList<Point> eggs = chicken.getEggs();

    if (eggs.contains(targetPoint)) {
        InventoryBar.getInstance().addItem(4);  // 添加鸡蛋到物品栏
    }
    eggs.remove(targetPoint);  // 移除已收集的鸡蛋
}
```

![image-20250912010409900](C:\Users\suin\AppData\Roaming\Typora\typora-user-images\image-20250912010409900.png)

### 4.11  时间系统与昼夜循环 

时间系统负责管理游戏内时间的流动、昼夜更替以及与之相关的视觉变化。

系统采用枚举类型定义四个时间阶段，每个阶段具有特定的起始时间和视觉覆盖效果：

- **黎明**（5-7点）：淡蓝色调，透明度50%，营造清晨氛围
- **白天**（7-17点）：无颜色覆盖，保持原始画面亮度
- **黄昏**（17-19点）：暖黄色调，透明度50%，呈现日落效果
- **夜晚**（19-5点）：深蓝色调，透明度100%，模拟夜间黑暗

<img src="C:\Users\suin\Desktop\OOFarm\src\assets\ui\time.png" alt="time" style="zoom:200%;" />

```java
public enum DayPhase {
    DAWN(5, new Color(150, 150, 200, 50)),      // 黎明 5-7点
    DAY(7, new Color(0, 0, 0, 0)),              // 白天 7-17点  
    DUSK(17, new Color(255, 200, 100, 50)),     // 黄昏 17-19点
    NIGHT(19, new Color(0, 0, 50, 100));        // 夜晚 19-5点

    public final int startHour;
    public final Color overlay;

    DayPhase(int startHour, Color overlay) {
        this.startHour = startHour;
        this.overlay = overlay;
    }
}
```

![image-20250912010712601](C:\Users\suin\AppData\Roaming\Typora\typora-user-images\image-20250912010712601.png)

![image-20250912010700652](C:\Users\suin\AppData\Roaming\Typora\typora-user-images\image-20250912010700652.png)

系统采用6秒/帧的更新频率，模拟时间的流动：

```java
public void update() {
    second = second + 6;
    if (second >= 60) {
        second = 0;
        minute++;
        if (minute >= 60) {
            minute = 0;
            hour++;
            if (hour >= 24) {
                hour = 0;
            }
            updatePhase();  // 小时变化时更新时段
        }
    }
}
```

![image-20250912010616290](C:\Users\suin\AppData\Roaming\Typora\typora-user-images\image-20250912010616290.png)

### 4.12  农场升级 

当与商人对话时，系统会检测玩家是否具备农场升级条件：通过 `checkItem(0)` 检查玩家金币数量，当金币达到100及以上且未升级过农场时，触发农场升级对话并执行升级操作。

```java
if (InventoryBar.checkItem(0) >= 100 && MainFrame.farmLevel != 1) {
    DialogBubble.talk(getClass().getSimpleName(), "update");
    MainFrame.updateFarm();
}
```

![image-20250912011525203](C:\Users\suin\AppData\Roaming\Typora\typora-user-images\image-20250912011525203.png)

通过提升农场等级来解锁更多的区域，（0级农场只有田地，1级农场解锁鸡圈）：

```java
public static void updateFarm() {
	if (farmLevel != 1) {
		farmLevel = 1;
		int money = InventoryBar.checkItem(0);
		InventoryBar.updateItem(0, money - 100);
	}
}
```

```java
if (farmLevel == 1) {
	chickenManager.render((Graphics2D) graphics); // 农场渲染小鸡
}
```

### 4.13 存档读档

游戏存档与读档系统实现了游戏状态的持久化存储和恢复功能，系统采用Java对象序列化技术，完整保存和还原游戏世界的所有关键状态，游戏数据保存在 `user.data` 中。

```java
public void saveGame(String filePath) {
    try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(filePath))) {
        // 写入时间系统
        oos.writeObject(timeSystem);

        // 写入PC位置
        oos.writeInt(pc.getX());
        oos.writeInt(pc.getY());
        oos.writeInt(pc.getDir());
        oos.writeUTF(mapViewer.nowMap.getLocationName());
        
        oos.writeObject(chickenManager.getChickens());
        oos.writeObject(farmManager.getPlants());
        oos.writeObject(inventoryBar.getItems());
    } catch (IOException e) {
        System.err.println("保存游戏失败：");
        e.printStackTrace();
    }
}

public void loadGame(String filePath) {
    try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filePath))) {
        // 读取时间系统
        timeSystem = (TimeSystem) ois.readObject();

        // 读取并恢复PC位置
        pc.setX(ois.readInt());
        pc.setY(ois.readInt());
        pc.setCurrentStatus(ois.readInt());
        mapViewer.updadteNowMap(ois.readUTF());

        List<Chicken> chickens = (List<Chicken>) ois.readObject(); // 读取鸡的List
        chickenManager.setChickens(chickens); // 将读取到的List设置到鸡管理器中

        HashMap<Integer, Plant> loadedPlants = (HashMap<Integer, Plant>) ois.readObject();
        farmManager.setPlants(loadedPlants);

        inventoryBar.setItems((List<Integer>) ois.readObject());
    } catch (IOException | ClassNotFoundException e) {
        System.err.println("加载游戏失败：");
        e.printStackTrace();
    }
}
```

## 5. 部署

本项目的最终部署方案采用 **Launch4j** 作为核心打包工具，将可执行的JAR文件与**嵌入式JRE运行环境**一同封装为完整的Windows平台原生EXE可执行文件。这一部署策略彻底消除了对用户系统环境的依赖，为用户提供开箱即用的稳定运行体验。

通过Launch4j的 advanced packaging 功能，将针对Windows平台优化后的JRE运行时完整嵌入到应用程序包中。这种嵌入式部署策略具有以下显著优势：首先，它完全避免了因用户系统缺少JRE或JRE版本不兼容导致的各类运行问题；其次，嵌入式JRE经过针对性精简，只包含运行所需的必要模块，有效控制了应用程序的总体积。用户无需执行复杂的安装配置流程，真正实现了双击即可运行的使用体验。

![image-20250912012007043](C:\Users\suin\AppData\Roaming\Typora\typora-user-images\image-20250912012007043.png)

![image-20250912012317481](C:\Users\suin\AppData\Roaming\Typora\typora-user-images\image-20250912012317481.png)

![image-20250912012325654](C:\Users\suin\AppData\Roaming\Typora\typora-user-images\image-20250912012325654.png)



